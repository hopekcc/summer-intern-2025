{% extends 'base.html' %}
{% block title %}Room {{ room_id }}{% endblock %}

{% block content %}
<section style="max-width:980px;margin:2rem auto;">
  <h1 style="margin-bottom:0.25rem;">Room: <code>{{ room_id }}</code></h1>
  <p>Share this code with your friends so everyone can view the same song and page together.</p>

  <!-- Authentication Status -->
  <div id="auth-status" style="padding:0.5rem;margin:1rem 0;border-radius:4px;display:none;">
    <span id="auth-message"></span>
  </div>

  <!-- Image Viewer -->
  <div style="margin:1rem 0;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
      <strong>Now Showing</strong>
      <span>
        <strong>Song:</strong> <span id="v-song">—</span>
        &nbsp;|&nbsp;
        <strong>Page:</strong> <span id="v-page">1</span>
      </span>
    </div>

    <div id="image-container" style="border:1px solid #e5e7eb;border-radius:8px;background:#fff;min-height:640px;display:flex;align-items:center;justify-content:center;">
      <img id="song-image" 
           style="max-width:100%;max-height:640px;display:none;" 
           alt="Song page" />
      <p id="image-hint" style="color:#777;margin:0;">
        Please sign in to view the song.
      </p>
    </div>
  </div>

  <!-- Host Controls -->
  <details id="host-controls" style="margin-top:1rem;display:none;">
    <summary>Host controls</summary>
    <div style="margin-top:0.75rem;display:flex;flex-wrap:wrap;gap:0.75rem;align-items:center;">
      <label>Song ID:
        <input id="songId" placeholder="e.g. believer" style="padding:0.4rem 0.6rem;">
      </label>
      <label>Page:
        <input id="page" type="number" min="1" value="1" style="width:5rem;padding:0.4rem 0.6rem;">
      </label>

      <button id="share" style="padding:0.45rem 0.8rem;">Share / Update</button>
      <button id="prev"  style="padding:0.45rem 0.8rem;">Prev</button>
      <button id="next"  style="padding:0.45rem 0.8rem;">Next</button>
    </div>
  </details>

  <p id="host-status" style="margin-top:1rem;color:#666;display:none;"></p>
  
  <!-- Connection Status -->
  <div style="margin-top:1rem;">
    <button id="refresh-status" style="padding:0.4rem 0.8rem;background:#f3f4f6;border:1px solid #d1d5db;border-radius:4px;cursor:pointer;">
      Refresh Room Status
    </button>
    <span id="connection-status" style="margin-left:1rem;color:#666;font-size:0.9em;">Connecting...</span>
  </div>
  
  <p style="margin-top:2rem;"><a href="/rooms/join">← Back to Join</a></p>
</section>
{% endblock %}

{% block scripts %}
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAQ3r-8kqsWOgBkWRKs-bApV33oeu-AICs",
    authDomain: "hopekcc-2024-summer-intern-api.firebaseapp.com",
    projectId: "hopekcc-2024-summer-intern-api",
    storageBucket: "hopekcc-2024-summer-intern-api.appspot.com",
    messagingSenderId: "172531116306",
    appId: "1:172531116306:web:d898ae28b5f79a425babcb"
  };
  
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);

  const roomId = "{{ room_id }}";
  const vSong = document.getElementById("v-song");
  const vPage = document.getElementById("v-page");
  const songImage = document.getElementById("song-image");
  const imageHint = document.getElementById("image-hint");
  const hostControls = document.getElementById("host-controls");
  const hostStatus = document.getElementById("host-status");
  const connectionStatus = document.getElementById("connection-status");
  const authStatus = document.getElementById("auth-status");
  const authMessage = document.getElementById("auth-message");
  const songInput = document.getElementById("songId");
  const pageInput = document.getElementById("page");
  const shareBtn = document.getElementById("share");
  const prevBtn = document.getElementById("prev");
  const nextBtn = document.getElementById("next");
  const refreshBtn = document.getElementById("refresh-status");

  let socket = null;
  let idToken = null;
  let currentUser = null;
  let isHost = false;
  let roomData = null;
  let lastUpdateTime = 0;
  let reconnectInterval = null;
  let shouldReconnect = true;
  let isConnecting = false;

  // WebSocket connection URL
  function getWebSocketUrl() {
    if (!idToken) return null;
    const scheme = location.protocol === "https:" ? "wss" : "ws";
    return `${scheme}://34.125.143.141:8000/ws?token=${encodeURIComponent(idToken)}`;
  }

  // Authentication state listener
  onAuthStateChanged(auth, async (user) => {
    currentUser = user;
    
    if (!user) {
      // User not signed in - clean up connections
      shouldReconnect = false;
      
      if (reconnectInterval) {
        clearInterval(reconnectInterval);
        reconnectInterval = null;
      }
      
      if (socket) {
        await closeExistingConnection();
      }
      
      // Reset UI
      idToken = null;
      isHost = false;
      showAuthStatus("Please sign in to view and sync the room.", "error");
      hostControls.style.display = 'none';
      hostStatus.style.display = 'block';
      hostStatus.textContent = "Please sign in to participate.";
      hostStatus.style.color = '#d00';
      connectionStatus.textContent = "Not connected";
      connectionStatus.style.color = '#6c757d';
      imageHint.textContent = "Please sign in to view the song.";
      songImage.style.display = 'none';
      return;
    }

    // User signed in - get token and initialize
    console.log('User signed in:', user.uid);
    try {
      idToken = await user.getIdToken(true);
      console.log('Token obtained');
      showAuthStatus(`Signed in as ${user.email}`, "success");
      
      shouldReconnect = true;
      
      // Initialize WebSocket connection - this will handle room state
      initializeWebSocket();
      
    } catch (error) {
      console.error('Error getting ID token:', error);
      showAuthStatus("Authentication error. Please refresh the page.", "error");
    }
  });

  function showAuthStatus(message, type) {
    authMessage.textContent = message;
    authStatus.style.display = 'block';
    
    if (type === 'success') {
      authStatus.style.backgroundColor = '#d1fae5';
      authStatus.style.color = '#065f46';
      authStatus.style.border = '1px solid #10b981';
    } else if (type === 'error') {
      authStatus.style.backgroundColor = '#fef2f2';
      authStatus.style.color = '#991b1b';
      authStatus.style.border = '1px solid #ef4444';
    }
  }

  // Make authenticated API request to WebSocket server
  async function makeAuthenticatedRequest(url, options = {}) {
    if (!idToken) {
      throw new Error('Not authenticated');
    }
    
    const headers = {
      'Authorization': `Bearer ${idToken}`,
      'Content-Type': 'application/json',
      ...options.headers
    };

    // All requests go to WebSocket server
    const fullUrl = url.startsWith('http') ? url : `http://34.125.143.141:8000${url}`;
    
    console.log('Making request to WebSocket server:', fullUrl);
    
    return fetch(fullUrl, { ...options, headers });
  }

  // Update host status based on WebSocket room state
  function updateHostStatus() {
    if (!roomData || !currentUser) return;
    
    isHost = roomData.host_id === currentUser.uid;
    
    if (isHost) {
      hostControls.style.display = 'block';
      hostStatus.style.display = 'block';
      hostStatus.textContent = 'You are the host of this room.';
      hostStatus.style.color = '#059669';
    } else {
      hostControls.style.display = 'none';
      hostStatus.style.display = 'block';
      hostStatus.textContent = 'You are viewing as a participant. Changes will sync in real-time.';
      hostStatus.style.color = '#6b7280';
    }
  }

  // Apply room state updates
  function applyState(state) {
    const song = state.songId || "";
    const page = state.page || 1;

    vSong.textContent = song || "—";
    vPage.textContent = page;

    if (isHost) { 
      songInput.value = song; 
      pageInput.value = page; 
    }

    lastUpdateTime = Date.now();
    if (!song) {
      songImage.style.display = 'none';
      imageHint.textContent = 'Please select a song.';
      return;
    }
    loadRoomImage().catch(() => {
      songImage.style.display = 'none';
      imageHint.textContent = 'Failed to load image.';
    });
  }

  // Load room image with authentication
  async function loadRoomImage() {
    if (!idToken || !vSong.textContent || vSong.textContent === "—") {
      songImage.style.display = 'none';
      imageHint.textContent = vSong.textContent === "—" ? "No song selected." : "Loading image...";
      return;
    }

    try {
      const cacheBuster = `t=${lastUpdateTime}`;
      const response = await makeAuthenticatedRequest(`/rooms/${roomId}/image?${cacheBuster}`);

      if (response.ok) {
        const blob = await response.blob();
        const imageUrl = URL.createObjectURL(blob);
        
        // Clean up previous blob URL
        if (songImage.src && songImage.src.startsWith('blob:')) {
          URL.revokeObjectURL(songImage.src);
        }
        
        songImage.src = imageUrl;
        songImage.style.display = 'block';
        imageHint.textContent = '';
      } else {
        songImage.style.display = 'none';
        imageHint.textContent = 'No image available.';
      }
    } catch (error) {
      console.error('Error loading image:', error);
      songImage.style.display = 'none';
      imageHint.textContent = 'Error loading image.';
    }
  }

  // WebSocket initialization
  async function initializeWebSocket() {
    const wsUrl = getWebSocketUrl();
    if (!wsUrl || isConnecting) return;
    
    isConnecting = true;
    
    // Properly close existing connection
    if (socket) {
      await closeExistingConnection();
    }

    try {
      socket = new WebSocket(wsUrl);
      
      socket.onopen = () => {
        connectionStatus.textContent = "Connected";
        connectionStatus.style.color = "#059669";
        isConnecting = false;
        
        // Clear any reconnect attempts
        if (reconnectInterval) { 
          clearInterval(reconnectInterval); 
          reconnectInterval = null; 
        }

        // Join the room and get initial state
        socket.send(JSON.stringify({ 
          event: 'join',
          room_id: roomId 
        }));
        socket.send(JSON.stringify({ 
          event: 'get_state',
          room_id: roomId 
        }));
      };

      socket.onmessage = (event) => {
        let msg; 
        try { 
          msg = JSON.parse(event.data); 
        } catch { 
          return; 
        }
        handleWebSocketMessage(msg);
      };

      socket.onclose = (event) => {
        isConnecting = false;
        connectionStatus.textContent = "Disconnected";
        connectionStatus.style.color = "#dc3545";
        
        if (shouldReconnect && event.code !== 1000) {
          scheduleReconnect();
        }
      };

      socket.onerror = (error) => {
        console.error('WebSocket error:', error);
        isConnecting = false;
        connectionStatus.textContent = "Connection Error";
        connectionStatus.style.color = "#dc3545";
      };

    } catch (error) {
      console.error('Failed to create WebSocket connection:', error);
      isConnecting = false;
      scheduleReconnect();
    }
  }

  // Handle WebSocket messages
  function handleWebSocketMessage(message) {
    console.log('Received WebSocket message:', message);
    
    const eventType = message.event || message.type;
    
    switch (eventType) {
      case 'connection_success':
        console.log('WebSocket authenticated');
        break;
        
      case 'join_room_success':
        console.log('Successfully joined room');
        // Handle initial room state
        roomData = message.room_state || {};
        updateHostStatus();
        if (roomData.current_song) {
          applyState({
            songId: roomData.current_song,
            page: roomData.current_page || 1
          });
        }
        break;
        
      case 'state_update':
      case 'room_state':
        console.log('Received room state:', message.data);
        if (message.data) {
          roomData = message.data;
          updateHostStatus();
          applyState({
            songId: message.data.song_id || message.data.current_song,
            page: message.data.page || message.data.current_page || 1
          });
        }
        break;
        
      case 'song_change':
      case 'song_updated':
        console.log('Song changed:', message.data);
        if (message.data) {
          roomData = { ...roomData, ...message.data };
          applyState({
            songId: message.data.song_id,
            page: message.data.page || 1
          });
        }
        break;
        
      case 'page_change':
      case 'page_updated':
        console.log('Page changed:', message.data);
        if (message.data) {
          roomData = { ...roomData, ...message.data };
          applyState({
            songId: roomData.song_id || roomData.current_song,
            page: message.data.page
          });
        }
        break;
        
      case 'error':
        console.error('WebSocket error:', message.data);
        connectionStatus.textContent = `Error: ${message.data?.message || 'Unknown error'}`;
        connectionStatus.style.color = "#dc3545";
        break;
        
      default:
        console.warn('Unknown message type:', eventType, message);
        break;
    }
  }

  // Connection management functions
  function closeExistingConnection() {
    return new Promise((resolve) => {
      if (!socket || socket.readyState === WebSocket.CLOSED) {
        resolve();
        return;
      }
      
      const closeTimeout = setTimeout(() => {
        console.warn('WebSocket close handshake timed out, forcing close');
        socket = null;
        resolve();
      }, 5000);
      
      socket.addEventListener('close', () => {
        clearTimeout(closeTimeout);
        socket = null;
        resolve();
      }, { once: true });
      
      if (socket.readyState === WebSocket.CLOSING) {
        return;
      }
      
      try {
        socket.close(1000, "Client closing");
      } catch (error) {
        console.error('Error closing WebSocket:', error);
        clearTimeout(closeTimeout);
        socket = null;
        resolve();
      }
    });
  }

  function scheduleReconnect() {
    if (reconnectInterval) return;
    
    reconnectInterval = setInterval(() => {
      if (!shouldReconnect) {
        clearInterval(reconnectInterval);
        reconnectInterval = null;
        return;
      }
      
      if (!isConnecting) {
        initializeWebSocket();
      }
    }, 5000);
  }

  // Host control handlers
  shareBtn.addEventListener("click", async () => {
    if (!isHost) return alert('Only the host can update the room state.');
    const song = songInput.value.trim();
    const page = parseInt(pageInput.value || "1", 10);

    try {
      shareBtn.disabled = true; 
      shareBtn.textContent = 'Updating...';
      
      if (song !== (roomData?.song_id || "")) {
        await makeAuthenticatedRequest(`/rooms/${roomId}/song`, {
          method: 'POST', 
          body: JSON.stringify({ song_id: song })
        });
      }
      if (page !== (roomData?.page || 1)) {
        await makeAuthenticatedRequest(`/rooms/${roomId}/page`, {
          method: 'POST', 
          body: JSON.stringify({ page })
        });
      }
    } catch (e) {
      alert('Failed to update room: ' + e.message);
    } finally {
      shareBtn.disabled = false; 
      shareBtn.textContent = 'Share / Update';
    }
  });

  prevBtn.addEventListener("click", async () => {
    if (!isHost) return alert('Only the host can change pages.');
    const currentPage = parseInt(pageInput.value || "1", 10);
    const newPage = Math.max(1, currentPage - 1);
    if (newPage === currentPage) return;
    
    try {
      prevBtn.disabled = true;
      await makeAuthenticatedRequest(`/rooms/${roomId}/page`, {
        method: 'POST', 
        body: JSON.stringify({ page: newPage })
      });
    } catch (e) {
      alert('Failed to change page: ' + e.message);
    } finally { 
      prevBtn.disabled = false; 
    }
  });

  nextBtn.addEventListener("click", async () => {
    if (!isHost) return alert('Only the host can change pages.');
    const currentPage = parseInt(pageInput.value || "1", 10);
    const newPage = currentPage + 1;
    
    try {
      nextBtn.disabled = true;
      await makeAuthenticatedRequest(`/rooms/${roomId}/page`, {
        method: 'POST', 
        body: JSON.stringify({ page: newPage })
      });
    } catch (e) {
      alert('Failed to change page: ' + e.message);
    } finally { 
      nextBtn.disabled = false; 
    }
  });

  refreshBtn.addEventListener("click", async () => {
    console.log('=== DEBUG INFO ===');
    console.log('Room ID:', roomId);
    console.log('Current User:', currentUser);
    console.log('ID Token exists:', !!idToken);
    console.log('Room Data:', roomData);
    console.log('Is Host:', isHost);
    console.log('WebSocket state:', socket?.readyState);
    
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        event: 'get_state',
        room_id: roomId
      }));
    } else if (currentUser && idToken) {
      initializeWebSocket();
    }
  });

  // Clean up on page unload
  window.addEventListener("beforeunload", async () => {
    shouldReconnect = false;
    
    if (reconnectInterval) {
      clearInterval(reconnectInterval);
      reconnectInterval = null;
    }
    
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.close(1000, "Page unloading");
    }
    
    if (songImage.src && songImage.src.startsWith('blob:')) {
      URL.revokeObjectURL(songImage.src);
    }
  });
</script>
{% endblock %}