{% extends 'base.html' %}
{% block title %}Room {{ room_id }}{% endblock %}

{% block content %}
<section style="max-width:980px;margin:2rem auto;">
  <h1 style="margin-bottom:0.25rem;">Room: <code>{{ room_id }}</code></h1>
  <p>Share this code with your friends so everyone can view the same song and page together.</p>

  <!-- Authentication Status -->
  <div id="auth-status" style="padding:0.5rem;margin:1rem 0;border-radius:4px;display:none;">
    <span id="auth-message"></span>
  </div>

  <!-- Image Viewer -->
  <div style="margin:1rem 0;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
      <strong>Now Showing</strong>
      <span>
        <strong>Song:</strong> <span id="v-song">—</span>
        &nbsp;|&nbsp;
        <strong>Page:</strong> <span id="v-page">1</span>
      </span>
    </div>

    <div id="image-container" style="border:1px solid #e5e7eb;border-radius:8px;background:#fff;min-height:640px;display:flex;align-items:center;justify-content:center;">
      <img id="song-image" 
           style="max-width:100%;max-height:640px;display:none;" 
           alt="Song page" />
      <p id="image-hint" style="color:#777;margin:0;">
        Please sign in to view the song.
      </p>
    </div>
  </div>

  <!-- Host Controls -->
  <details id="host-controls" style="margin-top:1rem;display:none;">
    <summary>Host controls</summary>
    <div style="margin-top:0.75rem;display:flex;flex-wrap:wrap;gap:0.75rem;align-items:center;">
      <label>Song ID:
        <input id="songId" placeholder="e.g. believer" style="padding:0.4rem 0.6rem;">
      </label>
      <label>Page:
        <input id="page" type="number" min="1" value="1" style="width:5rem;padding:0.4rem 0.6rem;">
      </label>

      <button id="share" style="padding:0.45rem 0.8rem;">Share / Update</button>
      <button id="prev"  style="padding:0.45rem 0.8rem;">Prev</button>
      <button id="next"  style="padding:0.45rem 0.8rem;">Next</button>
    </div>
  </details>

  <p id="host-status" style="margin-top:1rem;color:#666;display:none;"></p>
  
  <!-- Connection Status -->
  <div style="margin-top:1rem;">
    <button id="refresh-status" style="padding:0.4rem 0.8rem;background:#f3f4f6;border:1px solid #d1d5db;border-radius:4px;cursor:pointer;">
      Refresh Room Status
    </button>
    <span id="connection-status" style="margin-left:1rem;color:#666;font-size:0.9em;">Connecting...</span>
  </div>
  
  <p style="margin-top:2rem;"><a href="/rooms/join">← Back to Join</a></p>
</section>
{% endblock %}

{% block scripts %}
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAQ3r-8kqsWOgBkWRKs-bApV33oeu-AICs",
    authDomain: "hopekcc-2024-summer-intern-api.firebaseapp.com",
    projectId: "hopekcc-2024-summer-intern-api",
    storageBucket: "hopekcc-2024-summer-intern-api.appspot.com",
    messagingSenderId: "172531116306",
    appId: "1:172531116306:web:d898ae28b5f79a425babcb"
  };
  
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);

  const roomId = "{{ room_id }}";
  const vSong = document.getElementById("v-song");
  const vPage = document.getElementById("v-page");
  const songImage = document.getElementById("song-image");
  const imageHint = document.getElementById("image-hint");
  const hostControls = document.getElementById("host-controls");
  const hostStatus = document.getElementById("host-status");
  const connectionStatus = document.getElementById("connection-status");
  const authStatus = document.getElementById("auth-status");
  const authMessage = document.getElementById("auth-message");
  const songInput = document.getElementById("songId");
  const pageInput = document.getElementById("page");
  const shareBtn = document.getElementById("share");
  const prevBtn = document.getElementById("prev");
  const nextBtn = document.getElementById("next");
  const refreshBtn = document.getElementById("refresh-status");

  let socket = null;
  let idToken = null;
  let currentUser = null;
  let isHost = false;
  let roomData = null;
  let lastUpdateTime = 0;
  let reconnectInterval = null;

  // WebSocket connection URL (update this to match your WebSocket server)
function getWebSocketUrl() {
  if (!idToken) return null;
  const scheme = location.protocol === "https:" ? "wss" : "ws";
  return `${scheme}://34.125.143.141:8000/ws?token=${encodeURIComponent(idToken)}`;
}

  // Authentication state listener
  onAuthStateChanged(auth, async (user) => {
    currentUser = user;
    
    if (!user) {
      // User not signed in
      idToken = null;
      isHost = false;
      showAuthStatus("Please sign in to view and sync the room.", "error");
      
      if (socket) {
        socket.close();
        socket = null;
      }
      if (reconnectInterval) {
        clearInterval(reconnectInterval);
        reconnectInterval = null;
      }
      
      hostControls.style.display = 'none';
      hostStatus.style.display = 'block';
      hostStatus.textContent = "Please sign in to participate.";
      hostStatus.style.color = '#d00';
      connectionStatus.textContent = "Not connected";
      connectionStatus.style.color = '#6c757d';
      imageHint.textContent = "Please sign in to view the song.";
      songImage.style.display = 'none';
      return;
    }

    // User signed in - get token and initialize
    console.log('User signed in:', user.uid);
    try {
      idToken = await user.getIdToken(true);
      console.log('Token obtained');
      showAuthStatus(`Signed in as ${user.email}`, "success");
      
      // Initialize WebSocket and fetch room data
      initializeWebSocket();
      await fetchRoomDetails();
      
      // Retry if room data wasn't loaded
      if (!roomData) {
        console.log('Retrying room fetch...');
        setTimeout(fetchRoomDetails, 1000);
      }
    } catch (error) {
      console.error('Error getting ID token:', error);
      showAuthStatus("Authentication error. Please refresh the page.", "error");
    }
  });

  function showAuthStatus(message, type) {
    authMessage.textContent = message;
    authStatus.style.display = 'block';
    
    if (type === 'success') {
      authStatus.style.backgroundColor = '#d1fae5';
      authStatus.style.color = '#065f46';
      authStatus.style.border = '1px solid #10b981';
    } else if (type === 'error') {
      authStatus.style.backgroundColor = '#fef2f2';
      authStatus.style.color = '#991b1b';
      authStatus.style.border = '1px solid #ef4444';
    }
  }

  // Make authenticated API request
  async function makeAuthenticatedRequest(url, options = {}) {
    if (!idToken) {
      throw new Error('Not authenticated');
    }
    
    const headers = {
      'Authorization': `Bearer ${idToken}`,
      'Content-Type': 'application/json',
      ...options.headers
    };
    
    return fetch(url, { ...options, headers });
  }

  // Fetch room details from Flask server
  async function fetchRoomDetails() {
    if (!idToken) return;
    
    try {
      console.log('Fetching room details for room:', roomId);
      
      const response = await makeAuthenticatedRequest(`/rooms/${roomId}`);
      
      if (response.ok) {
        roomData = await response.json();
        console.log('Room data received:', roomData);
        updateHostStatus();
        updateDisplayFromRoomData();
      } else {
        console.error('Failed to fetch room details:', response.status);
        showAuthStatus("Failed to load room details", "error");
      }
    } catch (error) {
      console.error('Error fetching room details:', error);
      showAuthStatus("Error connecting to room", "error");
    }
  }

  // Update host status UI
  function updateHostStatus() {
    if (!roomData || !currentUser) return;
    
    isHost = roomData.host_id === currentUser.uid;
    
    if (isHost) {
      hostControls.style.display = 'block';
      hostStatus.style.display = 'block';
      hostStatus.textContent = 'You are the host of this room.';
      hostStatus.style.color = '#059669';
    } else {
      hostControls.style.display = 'none';
      hostStatus.style.display = 'block';
      hostStatus.textContent = 'You are viewing as a participant. Changes will sync in real-time.';
      hostStatus.style.color = '#6b7280';
    }
  }

  // Apply room state updates
// Update the applyState function to always force image reload
function applyState(state) {
  const song = state.songId || "";
  const page = state.page || 1;

  vSong.textContent = song || "—";
  vPage.textContent = page;

  if (isHost) { songInput.value = song; pageInput.value = page; }

  lastUpdateTime = Date.now();     // bust the image cache
  if (!song) {
    songImage.style.display = 'none';
    imageHint.textContent = 'Please select a song.';
    return;
  }
  loadRoomImage().catch(() => {
    songImage.style.display = 'none';
    imageHint.textContent = 'Failed to load image.';
  });
}


// Fix updateDisplayFromRoomData function
function updateDisplayFromRoomData() {
    if (!roomData) {
        console.log('No room data available');
        songImage.style.display = 'none';
        imageHint.textContent = 'Please select a song.';
        return;
    }
    
    console.log('Updating display from room data:', roomData);
    
    // Handle initial state when no song is selected
    if (!roomData.song_id) {
        vSong.textContent = "—";
        vPage.textContent = "1";
        songImage.style.display = 'none';
        imageHint.textContent = 'Please select a song.';
        if (isHost) {
            songInput.value = '';
            pageInput.value = '1';
        }
        return;
    }
    
    applyState({
        songId: roomData.song_id,
        page: roomData.page
    });
}


  // Load room image with authentication
async function loadRoomImage() {
    if (!idToken || !vSong.textContent || vSong.textContent === "—") {
        songImage.style.display = 'none';
        imageHint.textContent = vSong.textContent === "—" ? "No song selected." : "Loading image...";
        return;
    }

    try {
        const cacheBuster = `t=${lastUpdateTime}`;
        const response = await makeAuthenticatedRequest(`/rooms/${roomId}/image?${cacheBuster}`);

        if (response.ok) {
            const blob = await response.blob();
            const imageUrl = URL.createObjectURL(blob);
            
            // Clean up previous blob URL
            if (songImage.src && songImage.src.startsWith('blob:')) {
                URL.revokeObjectURL(songImage.src);
            }
            
            songImage.src = imageUrl;
            songImage.style.display = 'block';
            imageHint.textContent = '';
        } else {
            songImage.style.display = 'none';
            imageHint.textContent = 'No image available.';
        }
    } catch (error) {
        console.error('Error loading image:', error);
        songImage.style.display = 'none';
        imageHint.textContent = 'Error loading image.';
    }
}

  // WebSocket initialization
function initializeWebSocket() {
  const wsUrl = getWebSocketUrl();
  if (!wsUrl) return;
  if (socket && socket.readyState === WebSocket.OPEN) socket.close();

  socket = new WebSocket(wsUrl);

  socket.onopen = () => {
    connectionStatus.textContent = "Connected";
    connectionStatus.style.color = "#059669";
    if (reconnectInterval) { clearInterval(reconnectInterval); reconnectInterval = null; }

    // Join + request the current state
    socket.send(JSON.stringify({ type: 'join_room', room_id: roomId }));
    socket.send(JSON.stringify({ type: 'get_room_state', room_id: roomId }));
  };

  socket.onmessage = (event) => {
    let msg; try { msg = JSON.parse(event.data); } catch { return; }
    handleWebSocketMessage(msg);
  };

  socket.onclose = () => {
    connectionStatus.textContent = "Disconnected";
    connectionStatus.style.color = "#dc3545";
    if (!reconnectInterval) {
      reconnectInterval = setInterval(() => initializeWebSocket(), 5000);
    }
  };

  socket.onerror = () => {
    connectionStatus.textContent = "Connection Error";
    connectionStatus.style.color = "#dc3545";
  };
}

// Handle WebSocket messages
// Update the handleWebSocketMessage function for better real-time sync
function handleWebSocketMessage(message) {
  switch (message.type) {
    case 'room_joined':
      connectionStatus.textContent = "Joined room";
      connectionStatus.style.color = "#059669";
      break;
    case 'room_state':
      applyState({ songId: message.data.song_id, page: message.data.page });
      break;
    case 'song_updated':
      applyState({ songId: message.data.song_id, page: message.data.page || 1 });
      break;
    case 'page_updated':
      applyState({ songId: vSong.textContent === "—" ? "" : vSong.textContent, page: message.data.page });
      break;
    case 'error':
      connectionStatus.textContent = `Error: ${message.data?.message || 'Unknown error'}`;
      connectionStatus.style.color = "#dc3545";
      break;
  }
}

  // Update song on server
  async function updateSong(songId) {
    const response = await makeAuthenticatedRequest(`/rooms/${roomId}/song`, {
      method: 'POST',
      body: JSON.stringify({ song_id: songId })
    });
    
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to update song: ${error}`);
    }
  }

  // Update page on server
  async function updatePage(page) {
    const response = await makeAuthenticatedRequest(`/rooms/${roomId}/page`, {
      method: 'POST',
      body: JSON.stringify({ page: page })
    });
    
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to update page: ${error}`);
    }
  }

  // Host control handlers
// Update the song selection handler
// Update the share button handler
shareBtn.addEventListener("click", async () => {
  if (!isHost) return alert('Only the host can update the room state.');
  const song = songInput.value.trim();
  const page = parseInt(pageInput.value || "1", 10);

  try {
    shareBtn.disabled = true; shareBtn.textContent = 'Updating...';
    if (song !== (roomData?.song_id || "")) {
      await makeAuthenticatedRequest(`/rooms/${roomId}/song`, {
        method: 'POST', body: JSON.stringify({ song_id: song })
      });
      // Optional optimistic update:
      applyState({ songId: song, page: 1 });
    }
    if (page !== (roomData?.page || 1)) {
      await makeAuthenticatedRequest(`/rooms/${roomId}/page`, {
        method: 'POST', body: JSON.stringify({ page })
      });
      // Optional optimistic update:
      applyState({ songId: vSong.textContent === "—" ? "" : vSong.textContent, page });
    }
  } catch (e) {
    alert('Failed to update room: ' + e.message);
  } finally {
    shareBtn.disabled = false; shareBtn.textContent = 'Share / Update';
  }
});

prevBtn.addEventListener("click", async () => {
  if (!isHost) return alert('Only the host can change pages.');
  const currentPage = parseInt(pageInput.value || "1", 10);
  const newPage = Math.max(1, currentPage - 1);
  if (newPage === currentPage) return;
  try {
    prevBtn.disabled = true;
    await makeAuthenticatedRequest(`/rooms/${roomId}/page`, {
      method: 'POST', body: JSON.stringify({ page: newPage })
    });
    // Optional optimistic:
    applyState({ songId: vSong.textContent, page: newPage });
  } finally { prevBtn.disabled = false; }
});

nextBtn.addEventListener("click", async () => {
  if (!isHost) return alert('Only the host can change pages.');
  const currentPage = parseInt(pageInput.value || "1", 10);
  const newPage = currentPage + 1;
  try {
    nextBtn.disabled = true;
    await makeAuthenticatedRequest(`/rooms/${roomId}/page`, {
      method: 'POST', body: JSON.stringify({ page: newPage })
    });
    // Optional optimistic:
    applyState({ songId: vSong.textContent, page: newPage });
  } finally { nextBtn.disabled = false; }
});

  refreshBtn.addEventListener("click", async () => {
    console.log('=== DEBUG INFO ===');
    console.log('Room ID:', roomId);
    console.log('Current User:', currentUser);
    console.log('ID Token exists:', !!idToken);
    console.log('Room Data:', roomData);
    console.log('Is Host:', isHost);
    console.log('WebSocket state:', socket?.readyState);
    
    if (currentUser && idToken) {
        console.log('Attempting fresh room fetch...');
        await fetchRoomDetails();
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                event: 'get_state',  // Updated from type to event
                room_id: roomId
            }));
        }
    } else {
        console.log('Cannot fetch - missing user or token');
    }
});

  // Clean up on page unload
  window.addEventListener("beforeunload", () => {
    if (socket) {
      socket.close();
    }
    if (reconnectInterval) {
      clearInterval(reconnectInterval);
    }
    if (songImage.src && songImage.src.startsWith('blob:')) {
      URL.revokeObjectURL(songImage.src);
    }
  });
</script>
{% endblock %}