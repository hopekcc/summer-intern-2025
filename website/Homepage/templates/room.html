{# templates/room.html #}
{% extends 'base.html' %}
{% block title %}Room {{ room_id }}{% endblock %}

{% block content %}
  <h2>Room {{ room_id }}</h2>
  <div id="status" style="margin-bottom:1rem;">Connectingâ€¦</div>

  <!-- HOSTâ€ONLY: pick a song -->
  <div id="host-controls" style="display:none; margin:1em 0;">
    <label>
      Pick song:
      <select id="song-select">
        <option>Loading songsâ€¦</option>
      </select>
    </label>
    <button id="btn-set-song">Set Song</button>
  </div>

  <!-- PDF.js viewer widget -->
  <div class="pdf-widget">
    <div class="pdf-controls">
      <button id="prev">Prev</button>
      Page <span id="page_num">â€“</span> of <span id="page_count">â€“</span>
      <button id="next">Next</button>
    </div>
    <canvas id="pdf-render"></canvas>
  </div>
{% endblock %}

{% block scripts %}
<script type="module">
  // Firebase Auth
  import { auth } from "{{ url_for('static', filename='js/firebaseConfig.js') }}";
  import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

  // PDF.js
  import * as pdfjsLib from "{{ url_for('static', filename='pdfjs/build/pdf.mjs') }}";
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "{{ url_for('static', filename='pdfjs/build/pdf.worker.mjs') }}";

  const API_HOST = '34.125.143.141:8000';
  const API      = `http://${API_HOST}`;
  const roomId = "{{ room_id }}";

  // DOM refs
  const statusEl     = document.getElementById('status');
  const hostControls = document.getElementById('host-controls');
  const songSelect   = document.getElementById('song-select');
  const btnSetSong   = document.getElementById('btn-set-song');
  const prevBtn      = document.getElementById('prev');
  const nextBtn      = document.getElementById('next');
  const pageNumEl    = document.getElementById('page_num');
  const pageCountEl  = document.getElementById('page_count');
  const canvas       = document.getElementById('pdf-render');
  const ctx          = canvas.getContext('2d');

  let ws, token, myUid, hostId;
  let pdfDoc = null, pageNum = 1, isRendering = false, pendingPage = null;

  // 1) Authenticate, join room, load data, then open WebSocket
  onAuthStateChanged(auth, async user => {
    if (!user) return window.location.href = '/login';
    myUid = user.uid;
    token = await user.getIdToken(true);

    // join room
    await fetch(`${API}/rooms/join/${roomId}`, {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + token }
    });

    // load song list & room info
    await loadSongList();
    const currentSongId = await loadRoomInfo();
    if (currentSongId) {
      await loadAndRenderPDF();
      statusEl.textContent = '';
    }

    // open WebSocket
    connectWebSocket();
  });

  // Fetch songs for host dropdown
  async function loadSongList() {
    const res = await fetch(`${API}/songs/list`, {
      headers: { 'Authorization': 'Bearer ' + token }
    });
    if (!res.ok) {
      console.error('Failed to load songs:', res.status, await res.text());
      return;
    }
    const data = await res.json();
    const songs = Object.entries(data).map(([id, title]) => ({ id, title }));
    if (!songs.length) {
      songSelect.innerHTML = `<option>(no songs)</option>`;
      return;
    }
    songSelect.innerHTML = songs
      .map(s => `<option value="${s.id}">${s.title}</option>`)
      .join('');
  }

  // Fetch room metadata to detect host and bind host action
  async function loadRoomInfo() {
    const res  = await fetch(`${API}/rooms/${roomId}`, {
      headers: { 'Authorization': 'Bearer ' + token }
    });
    const info = await res.json();
    hostId = info.host || info.host_id;
    statusEl.textContent = `Host: ${hostId}`;
    if (hostId === myUid) {
      hostControls.style.display = 'block';
      // bind Set Song click only for host
      btnSetSong.addEventListener('click', async () => {
        if (myUid !== hostId) return;
        const songId = songSelect.value;
        console.log("â–¶ï¸ Host setting song:", songId);
        const res = await fetch(`${API}/rooms/${roomId}/song`, {
          method: 'POST',
          headers: {
            'Authorization': 'Bearer ' + token,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ song_id: songId })
        });
        console.log("â† /song status:", res.status, await res.text());
        if (!res.ok) {
          return alert("Error setting song");
        }
        // render immediately
        await loadAndRenderPDF();
        statusEl.textContent = '';
      });
    }
    return info.current_song_id;
  }

  // WebSocket setup & handlers
  // Use your FastAPI host/port for both HTTP & WS

  function connectWebSocket() {
    const wsProto = location.protocol === 'https:' ? 'wss://' : 'ws://';
    const wsUrl   = `${location.protocol==='https:'?'wss':'ws'}://${API_HOST}/ws/${roomId}`;
    console.log("ðŸ”— Connecting WebSocket to", wsUrl);

    ws = new WebSocket(wsUrl);

    ws.addEventListener('open', () => {
      console.log('âœ… WS open');
      statusEl.textContent = 'Connected';
      ws.send(JSON.stringify({ token }));
    });

    ws.addEventListener('message', ({ data }) => {
      const msg = JSON.parse(data);
      console.log('â† WS message', msg);
      if (msg.type === 'song_update') loadAndRenderPDF();
      if (msg.type === 'page_update') queueRender(msg.page);
    });

    ws.addEventListener('close', () => {
      console.log('âš ï¸ WS closed, reconnecting in 2s');
      setTimeout(connectWebSocket, 2000);
    });

    ws.addEventListener('error', e => {
      console.error('âŒ WS error', e);
    });
  }


  // Load & render the room PDF via PDF.js
  async function loadAndRenderPDF() {
    const res = await fetch(`${API}/rooms/${roomId}/pdf`, {
      headers: { 'Authorization': 'Bearer ' + token }
    });
    const buf = await res.arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument({ data: buf }).promise;
    pageCountEl.textContent = pdfDoc.numPages;
    pageNum = 1;
    renderPage(pageNum);
  }

  // PDF.js page rendering
  function renderPage(num) {
    isRendering = true;
    pdfDoc.getPage(num).then(page => {
      const viewport = page.getViewport({ scale: 1.5 });
      canvas.width  = viewport.width;
      canvas.height = viewport.height;
      page.render({ canvasContext: ctx, viewport }).promise.then(() => {
        isRendering = false;
        if (pendingPage !== null) {
          renderPage(pendingPage);
          pendingPage = null;
        }
      });
      pageNumEl.textContent = num;
    });
  }

  function queueRender(num) {
    isRendering ? (pendingPage = num) : renderPage(num);
  }

  // Prev/Next buttons broadcast page change
  prevBtn.addEventListener('click', () => {
    if (pageNum > 1) {
      pageNum--;
      ws.send(JSON.stringify({ type: 'host_page', page: pageNum }));
      queueRender(pageNum);
    }
  });
  nextBtn.addEventListener('click', () => {
    if (pageNum < pdfDoc.numPages) {
      pageNum++;
      ws.send(JSON.stringify({ type: 'host_page', page: pageNum }));
      queueRender(pageNum);
    }
  });
</script>
{% endblock %}