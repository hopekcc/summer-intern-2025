{% extends 'base.html' %}
{% block title %}Room {{ room_id }}{% endblock %}

{% block content %}
<section style="max-width:980px;margin:2rem auto;">
  <h1 style="margin-bottom:0.25rem;">Room: <code>{{ room_id }}</code></h1>
  <p>Share this code with your friends so everyone can view the same song and page together.</p>

  <!-- Authentication Status -->
  <div id="auth-status" style="padding:0.5rem;margin:1rem 0;border-radius:4px;display:none;">
    <span id="auth-message"></span>
  </div>

  <!-- Image Viewer -->
  <div style="margin:1rem 0;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
      <strong>Now Showing</strong>
      <span>
        <strong>Song:</strong> <span id="v-song">—</span>
        &nbsp;|&nbsp;
        <strong>Page:</strong> <span id="v-page">1</span>
      </span>
    </div>

    <div id="image-container" style="border:1px solid #e5e7eb;border-radius:8px;background:#fff;min-height:640px;display:flex;align-items:center;justify-content:center;">
      <img id="song-image" 
           style="max-width:100%;max-height:640px;display:none;" 
           alt="Song page" />
      <p id="image-hint" style="color:#777;margin:0;">
        Please sign in to view the song.
      </p>
    </div>
  </div>

  <!-- Host Controls -->
  <details id="host-controls" style="margin-top:1rem;display:none;">
    <summary>Host controls</summary>
    <div style="margin-top:0.75rem;display:flex;flex-wrap:wrap;gap:0.75rem;align-items:center;">
      <label>Song ID:
        <input id="songId" placeholder="e.g. believer" style="padding:0.4rem 0.6rem;">
      </label>
      <label>Page:
        <input id="page" type="number" min="1" value="1" style="width:5rem;padding:0.4rem 0.6rem;">
      </label>

      <button id="share" style="padding:0.45rem 0.8rem;">Share / Update</button>
      <button id="prev"  style="padding:0.45rem 0.8rem;">Prev</button>
      <button id="next"  style="padding:0.45rem 0.8rem;">Next</button>
    </div>
  </details>

  <p id="host-status" style="margin-top:1rem;color:#666;display:none;"></p>
  
  <!-- Connection Status -->
  <div style="margin-top:1rem;">
    <button id="refresh-status" style="padding:0.4rem 0.8rem;background:#f3f4f6;border:1px solid #d1d5db;border-radius:4px;cursor:pointer;">
      Refresh Room Status
    </button>
    <span id="connection-status" style="margin-left:1rem;color:#666;font-size:0.9em;">Connecting...</span>
  </div>
  
  <p style="margin-top:2rem;"><a href="/rooms/join">← Back to Join</a></p>
</section>
{% endblock %}

{% block scripts %}
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

  // === CONFIG (unchanged) ===
  const BACKEND_HTTP = "http://34.125.143.141:8000";
  const BACKEND_WS   = "ws://34.125.143.141:8000/ws";
  const roomId = "{{ room_id }}";

  const firebaseConfig = {
    apiKey: "AIzaSyAQ3r-8kqsWOgBkWRKs-bApV33oeu-AICs",
    authDomain: "hopekcc-2024-summer-intern-api.firebaseapp.com",
    projectId: "hopekcc-2024-summer-intern-api",
    storageBucket: "hopekcc-2024-summer-intern-api.appspot.com",
    messagingSenderId: "172531116306",
    appId: "1:172531116306:web:d898ae28b5f79a425babcb"
  };

  // === DOM (unchanged) ===
  const vSong = document.getElementById("v-song");
  const vPage = document.getElementById("v-page");
  const songImage = document.getElementById("song-image");
  const imageHint = document.getElementById("image-hint");
  const hostControls = document.getElementById("host-controls");
  const hostStatus = document.getElementById("host-status");
  const connectionStatus = document.getElementById("connection-status");
  const authStatus = document.getElementById("auth-status");
  const authMessage = document.getElementById("auth-message");
  const songInput = document.getElementById("songId");
  const pageInput = document.getElementById("page");
  const shareBtn = document.getElementById("share");
  const prevBtn = document.getElementById("prev");
  const nextBtn = document.getElementById("next");
  const refreshBtn = document.getElementById("refresh-status");

[prevBtn, nextBtn].forEach(b => {
  if (!b) return;
  b.style.minWidth = '110px';
  b.style.textAlign = 'center';
});


  // === STATE ===
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  let idToken = null;
  let currentUser = null;
  let isHost = false;
  let roomState = { host_id: null, current_song: "", current_page: 1, total_pages: null };

  let socket = null;
  let isConnecting = false;

  // === HELPERS ===
  function showAuthStatus(message, type) {
    authMessage.textContent = message;
    authStatus.style.display = 'block';
    authStatus.style.background = type === 'success' ? '#d1fae5' : '#fef2f2';
    authStatus.style.color = type === 'success' ? '#065f46' : '#991b1b';
    authStatus.style.border = type === 'success' ? '1px solid #10b981' : '1px solid #ef4444';
  }

  async function authedFetch(url, options = {}) {
    if (!idToken) throw new Error("Not authenticated");
    const headers = { ...(options.headers||{}), Authorization: `Bearer ${idToken}` };
    if (options.body && !headers["Content-Type"]) headers["Content-Type"] = "application/json";
    const res = await fetch(url, { ...options, headers });
    if (res.status === 401 && currentUser) {
      idToken = await currentUser.getIdToken(true);
      headers.Authorization = `Bearer ${idToken}`;
      return fetch(url, { ...options, headers });
    }
    return res;
  }

  function updateHostUI() {
    isHost = !!currentUser && roomState.host_id === currentUser.uid;
    hostControls.style.display = isHost ? 'block' : 'none';
    hostStatus.style.display = 'block';
    hostStatus.textContent = isHost ? 'You are the host of this room.' : 'Viewing as a participant. Changes sync in real time.';
    hostStatus.style.color = isHost ? '#059669' : '#6b7280';
  }

function updateNavButtons() {
  const page  = toIntOrNull(roomState.current_page) || 1;
  const total = toIntOrNull(roomState.total_pages);

  // Prev: hide on first page, but keep its position
  setHiddenKeepLayout(prevBtn, page <= 1);

  // Next: hide when we KNOW we’re at/over the last page
  const hideNext = Number.isFinite(total) && total > 0 && page >= total;
  setHiddenKeepLayout(nextBtn, hideNext);
  }


function applyState(s) {
  const songId = s.current_song ?? s.song_id ?? "";
  const page   = toIntOrNull(s.current_page ?? s.page) ?? 1;
  const hostId = s.host_id ?? roomState.host_id;

  // accept total_pages if present; otherwise keep previous
  const total  = toIntOrNull(s.total_pages) ?? roomState.total_pages;

  roomState = { host_id: hostId, current_song: songId, current_page: page, total_pages: total };

  vSong.textContent = songId || "—";
  vPage.textContent = page;

  if (isHost) { songInput.value = songId; pageInput.value = page; }
  updateHostUI();
  updateNavButtons();
  loadImage(); // unchanged
}



  async function loadImage() {
    const songId = roomState.current_song;
    const page   = roomState.current_page;

    if (!songId) {
      songImage.style.display = 'none';
      imageHint.textContent = 'No song selected.';
      updateNavButtons();
      return false;
    }

    const url = `${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}/image?t=${Date.now()}`;
    imageHint.textContent = 'Loading image...';
    songImage.style.display = 'none';

    try {
      const res = await authedFetch(url);
      if (res.status === 404) {
        // infer end-of-document
        roomState.total_pages = Math.max(roomState.total_pages || 0, Math.max(1, page - 1));
        updateNavButtons();
        imageHint.textContent = `No image for page ${page}.`;
        return false;
      }
      if (!res.ok) {
        imageHint.textContent = `Image error (${res.status}).`;
        return false;
      }
      const blob = await res.blob();
      const objUrl = URL.createObjectURL(blob);
      if (songImage.src && songImage.src.startsWith('blob:')) URL.revokeObjectURL(songImage.src);
      songImage.src = objUrl;
      songImage.style.display = 'block';
      imageHint.textContent = '';
      return true;
    } catch (e) {
      console.error("Image error:", e);
      imageHint.textContent = 'Error loading image.';
      return false;
    }
  }

  // === REST that mirrors /docs ===
  async function restJoinRoom() {
    await authedFetch(`${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}/join`, { method: "POST" });
  }
  async function restLeaveRoom() {
    await authedFetch(`${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}/leave`, { method: "POST" }).catch(()=>{});
  }
  async function restGetRoom() {
    const res = await authedFetch(`${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}`);
    if (!res.ok) throw new Error("Failed to get room");
    return res.json();
  }
  async function restSetSong(songId) {
    const res = await authedFetch(`${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}/song`, {
      method: "POST", body: JSON.stringify({ song_id: songId })
    });
    if (!res.ok) throw new Error(`set_song failed: ${res.status}`);
  }
  async function restSetPage(page) {
    const res = await authedFetch(`${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}/page`, {
      method: "POST", body: JSON.stringify({ page })
    });
    if (!res.ok) throw new Error(`set_page failed: ${res.status}`);
  }

  // === WS ===
  function wsOpen() { return socket && socket.readyState === WebSocket.OPEN; }

  function wsTrySend(payloads) {
    if (!wsOpen()) return false;
    try {
      payloads.forEach(p => socket.send(JSON.stringify(p)));
      return true;
    } catch { return false; }
  }

  async function initWS() {
    if (!idToken || isConnecting || wsOpen()) return;
    isConnecting = true;

    const sep = BACKEND_WS.includes("?") ? "&" : "?";
    const wsUrl = `${BACKEND_WS}${sep}token=${encodeURIComponent(idToken)}`;

    try {
      socket = new WebSocket(wsUrl);

      socket.onopen = () => {
        console.log('🟢 WebSocket connected');
        isConnecting = false;
        connectionStatus.textContent = "Connected";
        connectionStatus.style.color = "#059669";

    console.log('📤 Sending join messages for room:', roomId);
  
  // Send join messages and log each one
  const joinMessages = [
    { event: "join", room_id: roomId },
    { type:  "join", room_id: roomId },
    { action:"join_room", room_id: roomId },
    { op:    "join", room_id: roomId }
  ];
  
  joinMessages.forEach(msg => {
    console.log('📤 Sending join message:', msg);
    try {
      socket.send(JSON.stringify(msg));
      console.log('✅ Join message sent successfully');
    } catch (e) {
      console.error('❌ Failed to send join message:', e);
    }
  });
  
  // Request state
  console.log('📤 Sending state request messages for room:', roomId);
  const stateMessages = [
    { event: "get_state", room_id: roomId },
    { type:  "get_state", room_id: roomId }
  ];
  
  stateMessages.forEach(msg => {
    console.log('📤 Requesting state:', msg);
    try {
      socket.send(JSON.stringify(msg));
      console.log('✅ State request sent successfully');
    } catch (e) {
      console.error('❌ Failed to send state request:', e);
    }
  });
};

        socket.onmessage = (ev) => {
            console.log('🟢 WebSocket message received:', ev.data);
    let msg; 
    try { 
        msg = JSON.parse(ev.data); 
    } catch (e) { 
        console.error('❌ Failed to parse message:', ev.data, e);
        return; 
    }
    console.log('📦 Parsed message:', msg);
    console.log('🏷️ Message type:', msg.event || msg.type || msg.action || msg.op);
    const t = msg.event || msg.type || msg.action || msg.op;

      // ADD THIS CASE to handle connection_success
  if (t === "connection_success") {
    console.log('✅ WebSocket authenticated successfully');
    return;
  }

  // ADD THIS FALLBACK to see any unhandled messages
  console.log('⚠️ UNHANDLED WebSocket message type:', t, 'Full message:', msg);


    if (t === "join_room_success") {
        const st = msg.room_state || {};
        applyState({
        host_id: st.host_id,
        current_song: st.current_song ?? st.song_id,
        current_page: st.current_page ?? st.page,
        total_pages: st.total_pages
        });
        return;
    }

    if (t === "room_state" || t === "state_update" || t === "update") {
        if (msg.data) applyState({
        host_id: msg.data.host_id,
        current_song: msg.data.current_song ?? msg.data.song_id,
        current_page: msg.data.current_page ?? msg.data.page,
        total_pages: msg.data.total_pages
        });
        return;
    }

    if (t === "song_updated" || t === "song_change" || t === "set_song") {
        const d = msg.data || {};
        applyState({
        host_id: d.host_id ?? roomState.host_id,
        song_id: d.song_id ?? d.current_song ?? roomState.current_song,
        current_page: d.current_page ?? d.page ?? roomState.current_page,
        total_pages: d.total_pages
        });
        return;
    }

    if (t === "page_updated" || t === "page_change" || t === "set_page") {
        const d = msg.data || {};
        applyState({
        host_id: d.host_id ?? roomState.host_id,
        song_id: d.song_id ?? roomState.current_song,
        current_page: d.current_page ?? d.page ?? roomState.current_page,
        total_pages: d.total_pages
        });
        return;
    }
    };


      socket.onclose = () => {
        isConnecting = false;
        connectionStatus.textContent = "Disconnected";
        connectionStatus.style.color = "#dc3545";
      };
      socket.onerror = () => {
        isConnecting = false;
        connectionStatus.textContent = "Connection Error";
        connectionStatus.style.color = "#dc3545";
      };
    } catch (e) {
      console.error("WS init fail:", e);
      isConnecting = false;
    }
  }

  async function closeWS() {
    return new Promise((resolve) => {
      if (!socket) return resolve();
      const s = socket; socket = null;
      s.addEventListener('close', resolve, { once: true });
      try { s.close(1000, "Client closing"); } catch { resolve(); }
      setTimeout(resolve, 1200);
    });
  }

  // === AUTH FLOW ===
  onAuthStateChanged(auth, async (user) => {
    currentUser = user;
    if (!user) {
      showAuthStatus("Please sign in to view and sync the room.", "error");
      connectionStatus.textContent = "Not connected";
      connectionStatus.style.color = "#6c757d";
      hostControls.style.display = 'none';
      songImage.style.display = 'none';
      imageHint.textContent = "Please sign in to view the song.";
      await closeWS();
      idToken = null;
      return;
    }

    try {
      idToken = await user.getIdToken(true);
      showAuthStatus(`Signed in as ${user.email}`, "success");

      // Join via REST (server-side membership) and prime state
      await restJoinRoom();
      const st = await restGetRoom();
      applyState(st);

      // Subscribe live via WS
      initWS();
    } catch (e) {
      console.error(e);
      showAuthStatus("Authentication/Join failed. Refresh and try again.", "error");
    }
  });

  // === MUTATIONS: prefer WS broadcast, also persist via REST ===
  async function wsNotifySong(songId) {
    wsTrySend([
      { event: "set_song", room_id: roomId, song_id: songId },
      { type:  "set_song", room_id: roomId, song_id: songId },
      { action:"song",     room_id: roomId, data: { song_id: songId } }
    ]);
  }
  async function wsNotifyPage(page) {
    wsTrySend([
      { event: "set_page", room_id: roomId, page },
      { type:  "set_page", room_id: roomId, page },
      { action:"page",     room_id: roomId, data: { page } }
    ]);
  }
  async function wsRequestState() {
    wsTrySend([{ event:"get_state", room_id: roomId }, { type:"get_state", room_id: roomId }]);
  }

shareBtn.addEventListener("click", async () => {
  if (!isHost) return alert("Only the host can update the room.");
  const song = songInput.value.trim();
  let page = Math.max(1, parseInt(pageInput.value || "1", 10));

  // If total_pages is known and page is beyond it, clamp
  const total = roomState.total_pages;
  if (Number.isFinite(total) && total > 0) page = Math.min(page, total);

  try {
    shareBtn.disabled = true; shareBtn.textContent = "Updating…";
    if (song && song !== (roomState.current_song || "")) {
      wsNotifySong?.(song);
      await restSetSong(song);
      // After a song change the server should return the new total_pages in the next GET/WS
    }
    if (page !== (roomState.current_page || 1)) {
      wsNotifyPage?.(page);
      await restSetPage(page);
    }
    const st = await restGetRoom();   // should include total_pages
    applyState(st);
  } catch (e) {
    alert("Failed to update room: " + e.message);
  } finally {
    shareBtn.disabled = false; shareBtn.textContent = "Share / Update";
  }
});


prevBtn?.addEventListener("click", async () => {
  if (prevBtn.disabled || prevBtn.style.visibility === 'hidden') return;
  if (!isHost) return alert("Only the host can change pages.");
  if ((roomState.current_page || 1) <= 1) return;         // boundary guard

  const newPage = (roomState.current_page || 1) - 1;
  try {
    prevBtn.disabled = true;
    wsNotifyPage?.(newPage);                               // ok if you kept the WS helper
    await restSetPage(newPage);
    const st = await restGetRoom();
    applyState(st);
  } finally { prevBtn.disabled = false; }
});

nextBtn?.addEventListener("click", async () => {
  if (nextBtn.disabled || nextBtn.style.visibility === 'hidden') return;
  if (!isHost) return alert("Only the host can change pages.");

  const total = roomState.total_pages;
  const target = (roomState.current_page || 1) + 1;

  // If total_pages is known, block going past the end
  if (Number.isFinite(total) && total > 0 && target > total) return;

  try {
    nextBtn.disabled = true;
    wsNotifyPage?.(target);
    await restSetPage(target);
    const st = await restGetRoom();   // authoritative state (includes total_pages if server sends it)
    applyState(st);
  } finally { nextBtn.disabled = false; }
});


  // === DEBUG ===
  refreshBtn.addEventListener("click", async () => {
    console.log("DEBUG:", {
      roomId, user: currentUser?.uid, hasToken: !!idToken,
      roomState, isHost, ws: socket?.readyState
    });
    try { const st = await restGetRoom(); applyState(st); } catch {}
    wsRequestState();
    if (!wsOpen()) initWS();
  });

  // === CLEANUP ===
  window.addEventListener("beforeunload", async () => {
    try { await restLeaveRoom(); } catch {}
    await closeWS();
    if (songImage.src && songImage.src.startsWith('blob:')) URL.revokeObjectURL(songImage.src);
  });

function setHiddenKeepLayout(el, hidden) {
  if (!el) return;
  if (hidden) {
    el.style.visibility = 'hidden';      // keeps space
    el.style.pointerEvents = 'none';
    el.disabled = true;
    el.setAttribute('aria-hidden', 'true');
    el.tabIndex = -1;
  } else {
    el.style.visibility = 'visible';
    el.style.pointerEvents = '';
    el.disabled = false;
    el.removeAttribute('aria-hidden');
    el.tabIndex = 0; // or remove
  }
}

const toIntOrNull = v => {
  const n = Number.parseInt(v, 10);
  return Number.isFinite(n) ? n : null;
};

</script>
{% endblock %}
