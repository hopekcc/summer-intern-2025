{% extends 'base.html' %}
{% block title %}Room {{ room_id }}{% endblock %}

{% block content %}
<section style="max-width:980px;margin:2rem auto;">
  <h1 style="margin-bottom:0.25rem;">Room: <code>{{ room_id }}</code></h1>
  <p>Share this code with your friends so everyone can view the same song and page together.</p>

  <!-- Authentication Status -->
  <div id="auth-status" style="padding:0.5rem;margin:1rem 0;border-radius:4px;display:none;">
    <span id="auth-message"></span>
  </div>

  <!-- Image Viewer -->
  <div style="margin:1rem 0;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
      <strong>Now Showing</strong>
      <span>
        <strong>Song:</strong> <span id="v-song">—</span>
        &nbsp;|&nbsp;
        <strong>Page:</strong> <span id="v-page">1</span>
      </span>
    </div>

    <div id="image-container" style="border:1px solid #e5e7eb;border-radius:8px;background:#fff;min-height:640px;display:flex;align-items:center;justify-content:center;">
      <img id="song-image" 
           style="max-width:100%;max-height:640px;display:none;" 
           alt="Song page" />
      <p id="image-hint" style="color:#777;margin:0;">
        Please sign in to view the song.
      </p>
    </div>
  </div>

  <!-- Host Controls -->
  <details id="host-controls" style="margin-top:1rem;display:none;">
    <summary>Host controls</summary>
    <div style="margin-top:0.75rem;display:flex;flex-wrap:wrap;gap:0.75rem;align-items:center;">
      <label>Song ID:
        <input id="songId" placeholder="e.g. believer" style="padding:0.4rem 0.6rem;">
      </label>
      <label>Page:
        <input id="page" type="number" min="1" value="1" style="width:5rem;padding:0.4rem 0.6rem;">
      </label>

      <button id="share" style="padding:0.45rem 0.8rem;">Share / Update</button>
      <button id="prev"  style="padding:0.45rem 0.8rem;">Prev</button>
      <button id="next"  style="padding:0.45rem 0.8rem;">Next</button>
    </div>
  </details>

  <p id="host-status" style="margin-top:1rem;color:#666;display:none;"></p>
  
  <!-- Connection Status -->
  <div style="margin-top:1rem;">
    <button id="refresh-status" style="padding:0.4rem 0.8rem;background:#f3f4f6;border:1px solid #d1d5db;border-radius:4px;cursor:pointer;">
      Refresh Room Status
    </button>
    <span id="connection-status" style="margin-left:1rem;color:#666;font-size:0.9em;">Connecting...</span>
  </div>
  
  <p style="margin-top:2rem;"><a href="/rooms/join">← Back to Join</a></p>
</section>
{% endblock %}

{% block scripts %}
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

  // === CONFIG ===
  const BACKEND_HTTP = "http://34.125.143.141:8000";           // REST (per docs)
  const BACKEND_WS   = "ws://34.125.143.141:8000/ws";           // WS endpoint
  const roomId = "{{ room_id }}";

  const firebaseConfig = {
    apiKey: "AIzaSyAQ3r-8kqsWOgBkWRKs-bApV33oeu-AICs",
    authDomain: "hopekcc-2024-summer-intern-api.firebaseapp.com",
    projectId: "hopekcc-2024-summer-intern-api",
    storageBucket: "hopekcc-2024-summer-intern-api.appspot.com",
    messagingSenderId: "172531116306",
    appId: "1:172531116306:web:d898ae28b5f79a425babcb"
  };

  // === DOM ===
  const vSong = document.getElementById("v-song");
  const vPage = document.getElementById("v-page");
  const songImage = document.getElementById("song-image");
  const imageHint = document.getElementById("image-hint");
  const hostControls = document.getElementById("host-controls");
  const hostStatus = document.getElementById("host-status");
  const connectionStatus = document.getElementById("connection-status");
  const authStatus = document.getElementById("auth-status");
  const authMessage = document.getElementById("auth-message");
  const songInput = document.getElementById("songId");
  const pageInput = document.getElementById("page");
  const shareBtn = document.getElementById("share");
  const prevBtn = document.getElementById("prev");
  const nextBtn = document.getElementById("next");
  const refreshBtn = document.getElementById("refresh-status");

  // === STATE ===
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);

  let idToken = null;
  let currentUser = null;
  let isHost = false;
  let roomState = { host_id: null, current_song: "", current_page: 1 };

  let socket = null;
  let reconnectTimer = null;
  let isConnecting = false;

  // === HELPERS ===
  function showAuthStatus(msg, type) {
    authMessage.textContent = msg;
    authStatus.style.display = 'block';
    if (type === 'success') {
      authStatus.style.background = '#d1fae5';
      authStatus.style.color = '#065f46';
      authStatus.style.border = '1px solid #10b981';
    } else {
      authStatus.style.background = '#fef2f2';
      authStatus.style.color = '#991b1b';
      authStatus.style.border = '1px solid #ef4444';
    }
  }

  async function authedFetch(url, opts = {}) {
    if (!idToken) throw new Error("Not authenticated");
    const headers = {
      ...(opts.headers || {}),
      Authorization: `Bearer ${idToken}`,
      "Content-Type": opts.body ? "application/json" : (opts.headers || {})["Content-Type"]
    };
    const res = await fetch(url, { ...opts, headers });
    // simple 401 auto-refresh
    if (res.status === 401 && currentUser) {
      idToken = await currentUser.getIdToken(true);
      headers.Authorization = `Bearer ${idToken}`;
      return fetch(url, { ...opts, headers });
    }
    return res;
  }

  function updateHostUI() {
    isHost = !!currentUser && roomState.host_id === currentUser.uid;
    hostControls.style.display = isHost ? 'block' : 'none';
    hostStatus.style.display = 'block';
    hostStatus.textContent = isHost ? 'You are the host of this room.' : 'Viewing as a participant. Changes sync in real time.';
    hostStatus.style.color = isHost ? '#059669' : '#6b7280';
  }

  function applyState(s) {
    const songId = s.current_song ?? s.song_id ?? "";
    const page   = s.current_page ?? s.page ?? 1;
    const hostId = s.host_id ?? roomState.host_id;

    roomState = { host_id: hostId, current_song: songId, current_page: page };

    vSong.textContent = songId || "—";
    vPage.textContent = page;

    if (isHost) { songInput.value = songId; pageInput.value = page; }
    updateHostUI();
    loadImage();
  }

async function loadImage() {
  const songId = roomState.current_song;
  const page   = roomState.current_page;

  if (!songId) {
    songImage.style.display = 'none';
    imageHint.textContent = 'No song selected.';
    return;
  }

  const t = Date.now();
  const url = `${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}/image?t=${t}`;

  imageHint.textContent = 'Loading image...';
  songImage.style.display = 'none';

  try {
    const res = await authedFetch(url);
    if (res.status === 404) {
      imageHint.textContent = `No image for song "${songId}" page ${page}.`;
      return;
    }
    if (!res.ok) {
      imageHint.textContent = `Image error (${res.status}).`;
      return;
    }
    const blob = await res.blob();
    const objUrl = URL.createObjectURL(blob);
    if (songImage.src && songImage.src.startsWith('blob:')) URL.revokeObjectURL(songImage.src);
    songImage.src = objUrl;
    songImage.style.display = 'block';
    imageHint.textContent = '';
  } catch (e) {
    console.error("Image error:", e);
    imageHint.textContent = 'Error loading image.';
  }
}


  // === REST that mirrors /docs ===
  async function restJoinRoom() {
    const url = `${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}/join`;
    await authedFetch(url, { method: "POST" });
  }

  async function restLeaveRoom() {
    const url = `${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}/leave`;
    await authedFetch(url, { method: "POST" });
  }

  async function restGetRoom() {
    const url = `${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}`;
    const res = await authedFetch(url);
    if (!res.ok) throw new Error("Failed to get room");
    return res.json(); // { host_id, current_song, current_page, ... }
  }

  async function restSetSong(songId) {
  const url = `${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}/song`;
  const res = await authedFetch(url, { method: "POST", body: JSON.stringify({ song_id: songId }) });
  console.log("SetSong:", res.status);
  if (!res.ok) throw new Error(`set_song failed: ${res.status}`);
}

async function restSetPage(page) {
  const url = `${BACKEND_HTTP}/rooms/${encodeURIComponent(roomId)}/page`;
  const res = await authedFetch(url, { method: "POST", body: JSON.stringify({ page }) });
  console.log("SetPage:", res.status);
  if (!res.ok) throw new Error(`set_page failed: ${res.status}`);
}


  // === WS ===
  async function closeWS() {
    return new Promise((resolve) => {
      if (!socket) return resolve();
      const s = socket; socket = null;
      s.addEventListener('close', resolve, { once: true });
      try { s.close(1000, "Client closing"); } catch { resolve(); }
      setTimeout(resolve, 1200);
    });
  }

  function scheduleReconnect() {
    if (reconnectTimer) return;
    reconnectTimer = setInterval(() => {
      if (!isConnecting && idToken) initWS();
    }, 5000);
  }

  function initWS() {
    if (!idToken || isConnecting) return;
    isConnecting = true;

    const sep = BACKEND_WS.includes("?") ? "&" : "?";
    const wsUrl = `${BACKEND_WS}${sep}token=${encodeURIComponent(idToken)}`;

    closeWS().then(() => {
      try {
        socket = new WebSocket(wsUrl);
        socket.onopen = () => {
          isConnecting = false;
          connectionStatus.textContent = "Connected";
          connectionStatus.style.color = "#059669";
          if (reconnectTimer) { clearInterval(reconnectTimer); reconnectTimer = null; }
          // Ask WS for live state stream (server may also infer room from prior REST join)
          socket.send(JSON.stringify({ event: "join", room_id: roomId }));
          socket.send(JSON.stringify({ event: "get_state", room_id: roomId }));
        };

        socket.onmessage = (ev) => {
          let msg; try { msg = JSON.parse(ev.data); } catch { return; }
          const type = msg.event || msg.type;

          if (type === "join_room_success") {
            const st = msg.room_state || {};
            applyState({
              host_id: st.host_id,
              current_song: st.current_song,
              current_page: st.current_page ?? 1
            });
            return;
          }
          if (type === "room_state" || type === "state_update") {
            if (msg.data) applyState(msg.data);
            return;
          }
          if (type === "song_updated" || type === "song_change") {
            if (msg.data) applyState({ ...roomState, song_id: msg.data.song_id, page: msg.data.page ?? roomState.current_page });
            return;
          }
          if (type === "page_updated" || type === "page_change") {
            if (msg.data) applyState({ ...roomState, page: msg.data.page });
            return;
          }
        };

        socket.onclose = (e) => {
          isConnecting = false;
          connectionStatus.textContent = "Disconnected";
          connectionStatus.style.color = "#dc3545";
          if (e.code !== 1000) scheduleReconnect();
        };
        socket.onerror = () => {
          isConnecting = false;
          connectionStatus.textContent = "Connection Error";
          connectionStatus.style.color = "#dc3545";
          scheduleReconnect();
        };
      } catch (e) {
        console.error("WS init fail:", e);
        isConnecting = false;
        scheduleReconnect();
      }
    });
  }

  // === AUTH FLOW ===
  onAuthStateChanged(getAuth(), async (user) => {
    currentUser = user;

    if (!user) {
      showAuthStatus("Please sign in to view and sync the room.", "error");
      connectionStatus.textContent = "Not connected";
      connectionStatus.style.color = "#6c757d";
      hostControls.style.display = 'none';
      songImage.style.display = 'none';
      imageHint.textContent = "Please sign in to view the song.";
      await closeWS();
      if (reconnectTimer) { clearInterval(reconnectTimer); reconnectTimer = null; }
      idToken = null;
      return;
    }

    try {
      idToken = await user.getIdToken(true);
      showAuthStatus(`Signed in as ${user.email}`, "success");

      // 1) Ensure server knows we joined (REST)
      await restJoinRoom();

      // 2) Prime initial state (REST)
      const st = await restGetRoom();
      applyState(st);

      // 3) Subscribe to live updates (WS)
      initWS();
    } catch (e) {
      console.error(e);
      showAuthStatus("Authentication/Join failed. Refresh and try again.", "error");
    }
  });

  // === HOST CONTROLS (REST writes; WS will broadcast back) ===
shareBtn.addEventListener("click", async () => {
  if (!isHost) return alert("Only the host can update the room.");
  const song = songInput.value.trim();
  const page = Math.max(1, parseInt(pageInput.value || "1", 10));

  try {
    shareBtn.disabled = true; shareBtn.textContent = "Updating…";

    // Fire mutations (don’t over-optimize; let server decide if it’s a no-op)
    const ops = [];
    if (song) ops.push(restSetSong(song));
    ops.push(restSetPage(page));
    await Promise.all(ops);

    // Explicitly refresh state in case WS didn't broadcast
    const st = await restGetRoom();
    applyState(st);

  } catch (e) {
    console.error("Update error:", e);
    alert("Failed to update room: " + (e?.message || e));
  } finally {
    shareBtn.disabled = false; shareBtn.textContent = "Share / Update";
  }
});


prevBtn.addEventListener("click", async () => {
  if (!isHost) return alert("Only the host can change pages.");
  const newPage = Math.max(1, (roomState.current_page || 1) - 1);
  try {
    prevBtn.disabled = true;
    await restSetPage(newPage);
    const st = await restGetRoom();   // force-refresh
    applyState(st);
  } finally {
    prevBtn.disabled = false;
  }
});

nextBtn.addEventListener("click", async () => {
  if (!isHost) return alert("Only the host can change pages.");
  const newPage = (roomState.current_page || 1) + 1;
  try {
    nextBtn.disabled = true;
    await restSetPage(newPage);
    const st = await restGetRoom();   // force-refresh
    applyState(st);
  } finally {
    nextBtn.disabled = false;
  }
});

  // === DEBUG ===
  refreshBtn.addEventListener("click", async () => {
    console.log("DEBUG:", { roomId, user: currentUser?.uid, hasToken: !!idToken, ws: socket?.readyState, roomState, isHost });
    try {
      const st = await restGetRoom();
      applyState(st);
    } catch { /* ignore */ }
    if (!socket || socket.readyState !== WebSocket.OPEN) initWS();
  });

  // === CLEANUP ===
  window.addEventListener("beforeunload", async () => {
    try { await restLeaveRoom(); } catch {}
    await closeWS();
    if (songImage.src && songImage.src.startsWith('blob:')) URL.revokeObjectURL(songImage.src);
  });
</script>
{% endblock %}
